# Kafka Exactly Once
### Чтение из топика и запись в другой топик в одном кластере kafka.
Например потоковая обработка сообщений, как в приложении Kafka Streams.

Фиксируем смещение(offset) консюмера в одной транзакции с записью сообщений в другой топик.

Если транзакция прерывается, смещение консюмера вернется к своему старому значению, а данные отправленные в другой топик не будут видны другим консюмерам, в зависимости от их уровня изоляции.

- read_uncommitted - уровень изоляции по умолчанию.
  все сообщения видны потребителям, даже если они были частью прерванной транзакции.
- read_committed потребитель будет возвращать только сообщения из транзакций, которые были зафиксированы (а также любые сообщения, которые не были частью транзакции).

# Kafka Exactly Once (Effectivetly Once)
### Чтение из топика и запись во внешнюю систему.
Ограничение заключается в необходимости координировать фиксацию смещения консюмера и отправку данных во внешнюю систему.
- Классический способ - паттерн двухфазный коммит или сага.
- Способ получше, хранить во внешней системе не только данные, но и смещение консюмера. Таким образом можно отслеживать было ли сообщение с этим смещением обработано ранее.

При хранении смещения во внешней системе, есть смысл включить автофиксацию смещения консюмера, а не фиксировать его вручную. Это повысить производительность.

Второй вариант например использует Kafka Connect.

# Overview
Гарантия Exactly Once (точно один раз) в kafka представляет собой сочетание 2-х особенностей:
- идемпотентный продюсер
- транзакции продюсера

Идемпотентная доставка гарантирует, что сообщения будут доставлены ровно один раз в конкретный раздел топика (partition topic) в течение жизненного цикла одного продюсера.

Транзакционная доставка позволяет продюсерам отправлять данные в несколько разделов таким образом, что либо все сообщения будут успешно доставлены, либо ни одно из них.

Вместе эти возможности составляют семантику Exactly Once в Kafka.

## Идемпотентный продюсер
С точки зрения разработки, идемпотентный продюсер отличается от обычного включением `"enable.idempotence": "true"`
и обработкой фатальных ошибок `Error.IsFatal()`, возникающих, когда гарантии доставки exactly once не могут быть обеспечены.

Должны быть установлены:
```go
"enable.idempotence" = true
"max.in.flight.requests.per.connection" <= 5.
"retries" > 0
"acks"= all
```


Ошибки, для которых не установлен ни флаг retriable, abortable или fatal, не всегда очевидно, как их обрабатывать.
Общая рекомендация — рассматривать эти ошибки как fatal!
Экземпляр продюсера не может восстановиться после фатальных ошибок. Нужно завершить работу приложения.

### Как это работает
К каждому сообщению добавляется уникальный идентификатор продюсера(PID) и порядковый номер. Они вместе с целевым топиком и разделом однозначно идентифицируют сообщение.

Брокеры используют эти уникальные идентификаторы для отслеживания последних пяти (max.inflight.requests=5 по умолчанию) сообщений, созданных для каждого раздела на брокере.

Когда брокер получает сообщение, которое он уже принимал ранее, он отклоняет его с ошибкой.

### Сбои
#### перезапуск продюсера
Продюсер отправил сообщение брокеру и вышел из строя.
Новый продюсер, запущенный вместо прошлого, получит новый идентификатор.
Соответственно при отправке того-же сообщения ошибки не будет, т.к. идентификаторы продюсеров разные.

Exactly once не гарантируется.

Для сохранения гарантии доставки exactly once необходимо использовать транзакции на продюсере.

#### отказ брокера
Происходят перевыборы лидеров разделов которые были на отказавшем брокере.

## Транзакции
Для использования транзакций требуется кластер как минимум из 3-х брокеров.

Транзакции были созданы для сценария потоковой обработки. Чтение сообщения - обработка - запись сообщения.

### Producer
Экземпляр продюсера настраивается для транзакций путем установки `transactional.id` на уникальный для приложения идентификатор.
Обратите внимание, что
`enable.idempotence` должно быть включено.

Этот идентификатор будет использоваться для изоляции устаревших транзакций от предыдущих экземпляров приложения, обычно после сбоя или аварии.

После создания экземпляра транзакционного продюсера с помощью `NewProducer()` транзакционное состояние должно быть инициализировано вызовом `InitTransactions()`.
Это блокирующий вызов, который получит идентификатор продюсера от брокера, а также прервет все устаревшие транзакции и оградит все еще работающие экземпляры продюсера с тем же `transactional.id`.

После инициализации транзакций приложение может начать новую транзакцию, вызвав `BeginTransaction()`.
Экземпляр продюсера может иметь только одну единственную текущую транзакцию.

Любые сообщения, созданные после начала транзакции, будут принадлежать текущей транзакции и будут зафиксированы или отменены атомарно.

Все сообщения должны создаваться в рамках транзакции.

### Consumer
`"enable.auto.commit": "false"`
в кейсе kafka-kafka.

в кейсе kafka-сторонний сервис, в зависимости от реализации.

Уровень изоляции read committed должен быть установлен в консюмерах, читающих из топика, в который пишет транзакционный продюсер.
`"isolation.level": "read_committed"` 

## Examples
Пример реализации стратегии exactly once [kafka-kafka](https://github.com/arslanovdi/kafka_examples/tree/master/exactly-once/kafka-kafka).
